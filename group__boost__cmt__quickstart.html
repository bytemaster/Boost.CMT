<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost.CMT - Cooperative Multi-Tasking: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Quick Start<br/>
<small>
[<a class="el" href="group__boost__cmt.html">Boost.CMT</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<h2><a class="anchor" id="boost_cmt_async_same_thread">
Asynchronous Calls in Current Thread</a></h2>
<p>Here is a simple benchmark program that performs an asynchornous operation and waits on the result.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>boost::cmt;

    <span class="keywordtype">int</span> hello(<span class="keyword">const</span> std::string&amp; world ) {
        <span class="keywordflow">return</span> world.size(); 
    }

    <span class="keywordtype">void</span> bench() {
        ptime start = microsec_clock::universal_time();
        <span class="keywordtype">int</span> sum = 0;
        <span class="keywordflow">for</span>( uint32_t i = 0; i &lt; 1000; ++i ) 
            sum += async&lt;int&gt;( boost::bind(hello, <span class="stringliteral">&quot;world&quot;</span>), <span class="stringliteral">&quot;hello_func&quot;</span> ).wait();
        ptime end = microsec_clock::universal_time();
        slog( <span class="stringliteral">&quot;%1% calls/sec&quot;</span>, (1000.0/((stop-start).total_microseconds()/1000000.0)) );
    }

    <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
        async( bench );
        boost::cmt::exec(); 
    }
</pre></div><p>In the code above, <a class="el" href="">boost::cmt::async&lt;int&gt;(functor) </a> takes a functor that takes 0 parameters and returns an integer. The result is a boost::cmt::future&lt;int&gt; which will not block until wait() is called.</p>
<h2><a class="anchor" id="boost_cmt_async_signal_wait">
Asynchronously wait on a Signal</a></h2>
<p>This example shows how a task can wait on an event triggered by a boost::signal.</p>
<div class="fragment"><pre class="fragment">    boost::signal&lt;void(std::string)&gt; test_signal;
   
    <span class="keywordtype">void</span> delay()
    {
        boost::cmt::usleep(2000000);
        test_signal(<span class="stringliteral">&quot;hello world!&quot;</span>);
    }

    <span class="keywordtype">void</span> wait_on_signal() {
        std::string rtn = boost::cmt::wait(test_signal);
    }

    <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
         async( delay );
         async( wait_on_signal );
         boost::cmt::exec(); 
    }
</pre></div><h2><a class="anchor" id="boost_cmt_interthread">
Inter-thread Invocations</a></h2>
<p>Sometimes you really want things to happen in parallel on multiple real CPU cores. In this case you will need to have some kind of inter-thread synchronization. Boost.CMT enables lock-free interthread communication by posting tasks to an appropriate event queue and returning a <a class="el" href="classboost_1_1cmt_1_1future.html" title="placeholder for the result of an asynchronous operation.">boost::cmt::future</a>.</p>
<div class="fragment"><pre class="fragment">        <a class="code" href="classboost_1_1cmt_1_1thread.html" title="manages cooperative scheduling of tasks within a single operating system thread.">boost::cmt::thread</a>* t = boost::cmt::thread::create();
        future&lt;int&gt; fut_val = t-&gt;async( boost::bind( hello, <span class="stringliteral">&quot;world&quot;</span> ) );
        <span class="keywordtype">int</span> val = t-&gt;sync( boost::bind( hello, <span class="stringliteral">&quot;world&quot;</span> ) );
        <span class="keywordtype">int</span> val2 = fut_val.wait();
</pre></div><p>In this example I introduce a new method, <code>thread::sync&lt;rtn&gt;(functor)</code>, which is identical to <code>thread::async&lt;rtn&gt;(functor).wait()</code> except that it can avoid extra heap allocations because it knows that the boost::cmt::promise's life will not excede the scope of thread::sync and therefore the promise can be allocated on the stack.</p>
<h2><a class="anchor" id="boost_cmt_usleep">
Yielding and Sleeping</a></h2>
<p>The current task can either yield and allow other tasks to run before returning or it can sleep for an specific amount of time while allowing other tasks to run.</p>
<div class="fragment"><pre class="fragment">        boost::cmt::usleep(100000<span class="comment">/*us*/</span>);
        boost::cmt::yield();

        <span class="comment">// or the more verbose...</span>
        boost::cmt::thread::current().usleep(10000);
        boost::cmt::thread::current().yield();
</pre></div><p>You can only yield or sleep for the current thread. If there are no other tasks ready to run then yield() returns immediately. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jul 27 22:26:30 2011 for Boost.CMT - Cooperative Multi-Tasking by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
